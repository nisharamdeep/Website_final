---
title: BlogPost1
author: ''
date: '2019-12-15'
slug: blogpost1
categories: []
tags: []
description: ''
---



<div id="using-python" class="section level2">
<h2>Using Python</h2>
<p>In class, we have been using Python to do a couple of interesting things. These include using regular expressions (regex) to find matches of certain characters in strings, almost like ctrl+f.</p>
<p>For example:</p>
<pre class="python"><code>import re

string = &quot;We have to extract these numbers 12, 47, 48 The integers numbers are also interesting: 189 2036 314\&#39;,\&#39; is a separator, so please extract these numbers 125,789,1450 and also these 564,90456 We like to offer you 7890$ per month in order to complete this task... we are joking&quot;

re.findall(r&#39;\d+&#39;, string)</code></pre>
<pre><code>## [&#39;12&#39;, &#39;47&#39;, &#39;48&#39;, &#39;189&#39;, &#39;2036&#39;, &#39;314&#39;, &#39;125&#39;, &#39;789&#39;, &#39;1450&#39;, &#39;564&#39;, &#39;90456&#39;, &#39;7890&#39;]</code></pre>
<p>Given that simple string, we were able to use a regex to extract all of the numbers. This can be useful when you need certain information from a large document quickly.</p>
<p>We can also use it for slightly more complicated strings.</p>
<p>For example:</p>
<pre class="python"><code>string1 = r&quot;We try to quantitatively capture these characteristics by defining a set of indexes,\
which can be computed using the mosaic image and the corresponding ground truth: \
\begin{itemize} \
    \item $\mu_{A_T}$ and $\sigma_{A_T}$, the mean and standard deviation of the tiles area $A_T$, respectively; \
    \item $\rho_\text{filler}$, the ratio between the filler area and the overall mosaic are, computed as \
$\rho_\text{filler}=\frac{\sum_{T \in \mathcal{T} A_T}}{A}$, being $A$ the area of the mosaic; \
    \item \todo{does it worth?}; \
    \item \todo{does it worth?}; \
    \item $\mu_{C_T}$, the mean of the tiles \emph{color dispersion} $C_T$, \
being $C_T = \sigma_R+\sigma_G+\sigma_B$, where $\sigma_R$, $\sigma_G$ and $\sigma_B$ are the \
standard deviation of the red, green and blue channel values of the pixels within the tile $T$.\
After applying a method to an image, we compare the segmented image (i.e., the result) \
against the ground truth and assess the performance according to the following three metrics: \
\begin{itemize} \
    \item average tile precision $P$ \
    \item average tile recall $R$ \
    \item tile count error $C$&quot;

re.findall(r&#39;\$[^$]+\$&#39;, string1)</code></pre>
<pre><code>## [&#39;$\\mu_{A_T}$&#39;, &#39;$\\sigma_{A_T}$&#39;, &#39;$A_T$&#39;, &#39;$\\rho_\\text{filler}$&#39;, &#39;$\\rho_\\text{filler}=\\frac{\\sum_{T \\in \\mathcal{T} A_T}}{A}$&#39;, &#39;$A$&#39;, &#39;$\\mu_{C_T}$&#39;, &#39;$C_T$&#39;, &#39;$C_T = \\sigma_R+\\sigma_G+\\sigma_B$&#39;, &#39;$\\sigma_R$&#39;, &#39;$\\sigma_G$&#39;, &#39;$\\sigma_B$&#39;, &#39;$T$&#39;, &#39;$P$&#39;, &#39;$R$&#39;, &#39;$C$&#39;]</code></pre>
<p>This time we used a regex to extract all of the latex math-mode text from a large string.</p>
<p>We also used Python to find the different k-mers that could be obtained from a DNA sequence.</p>
<p>For example:</p>
<pre class="python"><code>my_seq = &quot;CAGCCCAATCAGGCTCTACTGCCACTAAACTTACGCAGGATATATTTACGCCGACGTACT&quot;

def count_kmers(read):

    k = 3
    count = {}
    num = len(read) - 2
    for i in range(num):
        threemer = read[i:i+k]
        if threemer not in count:
            count[threemer] = 0
        count[threemer] += 1
    return count
count_kmers(my_seq)</code></pre>
<pre><code>## {&#39;CAG&#39;: 3, &#39;AGC&#39;: 1, &#39;GCC&#39;: 3, &#39;CCC&#39;: 1, &#39;CCA&#39;: 2, &#39;CAA&#39;: 1, &#39;AAT&#39;: 1, &#39;ATC&#39;: 1, &#39;TCA&#39;: 1, &#39;AGG&#39;: 2, &#39;GGC&#39;: 1, &#39;GCT&#39;: 1, &#39;CTC&#39;: 1, &#39;TCT&#39;: 1, &#39;CTA&#39;: 2, &#39;TAC&#39;: 4, &#39;ACT&#39;: 4, &#39;CTG&#39;: 1, &#39;TGC&#39;: 1, &#39;CAC&#39;: 1, &#39;TAA&#39;: 1, &#39;AAA&#39;: 1, &#39;AAC&#39;: 1, &#39;CTT&#39;: 1, &#39;TTA&#39;: 2, &#39;ACG&#39;: 3, &#39;CGC&#39;: 2, &#39;GCA&#39;: 1, &#39;GGA&#39;: 1, &#39;GAT&#39;: 1, &#39;ATA&#39;: 2, &#39;TAT&#39;: 2, &#39;ATT&#39;: 1, &#39;TTT&#39;: 1, &#39;CCG&#39;: 1, &#39;CGA&#39;: 1, &#39;GAC&#39;: 1, &#39;CGT&#39;: 1, &#39;GTA&#39;: 1}</code></pre>
<p>Given that sequence, we were able to generate a dictionary with all of the possible k-mers.</p>
<p>Overall, Python has been very interesting, and I hope to continue to learn more!</p>
</div>
